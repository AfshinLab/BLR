from snakemake.utils import validate
from blr.utils import ReadGroup

configfile: "blr.yaml"
validate(config, "config.schema.yaml")

# TODO include handling of reads from `longranger basic` that already have barcodes extracted and trimmed? See issue
#  in ema when discussed https://github.com/arshajii/ema/issues/15

# Import rules for trimming fastq files.
if config["library_type"] == "blr":
    include: "rules/trim_blr.smk"
elif config["library_type"] == "10x":
    include: "rules/trim_10x.smk"
elif config["library_type"] == "stlfr":
    include: "rules/trim_stlfr.smk"

# Import rules for phasing
include: "rules/phasing.smk"

# Create read group string to tag reads.
platform = "DNBSEQ" if config["library_type"] == "stlfr" else "ILLUMINA"
readgroup = ReadGroup(identifier="1", library=config['library_type'], sample="20", platfrom_unit="unit1",
                      platform=platform)

def get_final_targets(wildcards):
    """Define final file names based on configs."""
    input_files = [
        "reads.1.final.fastq.gz",
        "reads.2.final.fastq.gz",
        "multiqc_report.html"
    ]
    if config["reference_variants"] and config["phasing_ground_truth"]:
        input_files.append("phasing_stats.txt")

    if config["variant_caller"] == "gatk" and config["BQSR"]:
        input_files.append(f"mapped.sorted.tag.bcmerge.mkdup.mol.filt.BQSR.phase.bam")
    else:
        input_files.append(f"mapped.sorted.tag.bcmerge.mkdup.mol.filt.phase.bam")

    return input_files


rule final:
   input:
        get_final_targets


rule fastqc_raw_reads:
    """Creates fastqc reports from raw read files. Output names are automatically given by fastqc."""
    output:
        qc = expand("trimmed.barcoded.{nr}_fastqc.html", nr=(1,2)),
        zip = expand("trimmed.barcoded.{nr}_fastqc.zip", nr=(1,2))
    input:
        reads = expand("trimmed.barcoded.{nr}.fastq.gz", nr=(1,2)),
    log:
        "fastqc_raw_reads.log"
    shell:
        "fastqc"
        " {input.reads}"
        " 2> {log}"


def get_multiqc_input(wildcards):
    inputs = [
        "trimmed.barcoded.1_fastqc.html",
        "trimmed.barcoded.2_fastqc.html",
        "mapped.sorted.tag.bcmerge.mkdup.mol.filt.bam",
        "figures/mapped",
    ]
    if config["reference_variants"] and config["phasing_ground_truth"]:
        inputs.append("phasing_stats.tsv")

    return inputs

rule multiqc_summarize:
    """Summarizes all reports into one html report. Automatically identifies input/gives output names but by adding
    more input files it controls when snakemake runs the multiqc summary.
    """
    output:
        multiqc_data_dir = directory("multiqc_data"),
        summarized_reports = "multiqc_report.html"
    input:
        get_multiqc_input
    log:
        "multiqc.log"
    shell:
        "multiqc"
        " ."
        " 2> {log}"


def plot_figures_input(wildcards):
    if config["library_type"] == "blr":
        return "{wc.base}.molecule_stats.tsv".format(wc=wildcards), "barcodes.clstr"
    else:
        return "{wc.base}.molecule_stats.tsv".format(wc=wildcards)


# TODO individual molecule_stats.tsv files should be merged so that we get only one plot
rule plot_figures:
    """Generate plots for final report."""
    output: directory("figures/{base}")
    input: plot_figures_input
    log: "{base}.plot_figures.log"
    shell:
        "blr plot"
        " {input}"
        " -o {output} 2> {log}"


rule barcode_sort_fastq:
    """Assumes barcode read name is followed by barcode sequence. Required for EMA aligner.
    Exmaple: @ST-E00269:339:H27G2CCX2:7:1102:21186:8060:AAAAAAAATATCTACGCTCA BX:Z:AAAAAAAATATCTACGCTCA
    """
    output:
        fastq = "sorted.{nr}.fastq.gz"
    input:
        fastq = "trimmed.barcoded.{nr}.fastq.gz"
    shell:
        "pigz -cd -p 1 {input.fastq} |"
        " paste - - - - |"
        " sort -t ' ' -k2 |"
        " tr '\t' '\n' |"
        " pigz > {output.fastq}"


rule map_sort_tag:
    """Map reads using the aligner specified in configs. Output is sorted and tagged with barcode."""
    output:
        bam = "mapped.sorted.bam"
    input:
        r1_fastq = "trimmed.barcoded.1.fastq.gz" if config["read_mapper"] != "ema" else "sorted.1.fastq.gz",
        r2_fastq = "trimmed.barcoded.2.fastq.gz" if config["read_mapper"] != "ema" else "sorted.2.fastq.gz"
    threads: 20
    log:
        map = "mapped.sorted.bam.map.log",
        sort = "mapped.sorted.bam.sort.log"
    run:
        commands = {
            "bwa":
                "bwa mem"
                " -t {threads}"
                " -R {readgroup}"
                " {config[genome_reference]}"
                " {input.r1_fastq}"
                " {input.r2_fastq}",
            "bowtie2":
                "bowtie2"
                " -p {threads}"
                " --rg-id {readgroup.identifier}"
                " --rg {readgroup.LB}"
                " --rg {readgroup.SM}"
                " --rg {readgroup.PU}"
                " --rg {readgroup.PL}"
                " --reorder"
                " --maxins 2000"
                " -x {config[genome_reference]}"
                " -1 {input.r1_fastq}"
                " -2 {input.r2_fastq}",
            "minimap2":
                "minimap2"
                " -ax sr"
                " -R {readgroup}"
                " -t {threads}"
                " {config[genome_reference]}"
                " {input.r1_fastq}"
                " {input.r2_fastq}",
            "ema":
                "ema align"
                " -1 <(pigz -cd {input.r1_fastq})"
                " -2 <(pigz -cd {input.r2_fastq})"
                " -R {readgroup}"
                " -r {config[genome_reference]}"
                " -t {threads}"
                " -p 10x"
        }
        command = commands[config["read_mapper"]].format(**locals(), **globals())

        shell(
            "{command} 2> {log.map} |"
            "samtools sort -"
            " -@ {threads}"
            " -o {output.bam} 2> {log.sort}"
        )


rule tagbam:
    output:
        bam = "{base}.sorted.tag.bam"
    input:
        bam = "{base}.sorted.bam"
    log:
        "{base}.sorted.tag.bam.log"
    shell:
        "blr tagbam {input.bam} -o {output.bam} 2> {log}"


rule clusterrmdup:
    """Merge cluster duplicates defined as two separate cluster sharing """
    output:
        bam = "{base}.sorted.tag.bcmerge.bam",
        merges = "{base}.barcode-merges.csv"
    input:
        bam = "{base}.sorted.tag.bam"
    log: "{base}.sorted.tag.bcmerge.bam.log"
    shell:
        "blr clusterrmdup"
        " {input.bam}"
        " {output.merges}"
        " -o {output.bam}"
        " -b {config[cluster_tag]} 2> {log}"


rule mark_duplicates:
    """Mark duplicates within barcodes clusters."""
    output:
        bam = "{base}.sorted.tag.bcmerge.mkdup.bam",
        metrics = "{base}.sorted.tag.bcmerge.mkdup_metrics.txt"
    input:
        bam = "{base}.sorted.tag.bcmerge.bam"
    log: "{base}.sorted.tag.bcmerge.mkdup.bam.log"
    shell:
        "picard MarkDuplicates"
        " INPUT={input.bam}"
        " OUTPUT={output.bam}"
        " METRICS_FILE={output.metrics}"
        " BARCODE_TAG={config[cluster_tag]}"
        # Running without `USE_JDK_DEFLATER=true` & `USE_JDK_INFLATER=true` causes fatal error. See issue: 
        # https://github.com/broadinstitute/picard/issues/1329
        " USE_JDK_DEFLATER=true"
        " USE_JDK_INFLATER=true"
        " ASSUME_SORTED=true"
        " &> {log}"


rule buildmolecules:
    """Groups reads into molecules depending on their genomic position and barcode"""
    output:
        bam = "{base}.sorted.tag.bcmerge.mkdup.mol.bam",
        stats = "{base}.molecule_stats.tsv"
    input:
        bam = "{base}.sorted.tag.bcmerge.mkdup.bam"
    log: "{base}.buildmolecules.log"
    shell:
        "blr buildmolecules"
        " {input.bam}"
        " -o {output.bam}"
        " --stats-tsv {output.stats}"
        " -m {config[molecule_tag]}"
        " -n {config[num_mol_tag]}"
        " -b {config[cluster_tag]}"
        " 2> {log}"


# filterclusters creates a .bai file directly
ruleorder: filterclusters > index_bam


rule filterclusters:
    """Filter clusters based on number of molecules. Remove duplicates from BAM"""
    output:
        bam = "{base}.sorted.tag.bcmerge.mkdup.mol.filt.bam",
        bai = "{base}.sorted.tag.bcmerge.mkdup.mol.filt.bam.bai"
    input:
        bam = "{base}.sorted.tag.bcmerge.mkdup.mol.bam"
    log: "{base}.filterclusters.log"
    shell:
        "blr filterclusters"
        " {input.bam}"
        " -m {config[molecule_tag]}"
        " -n {config[num_mol_tag]}"
        " -b {config[cluster_tag]}"
        " -M {config[max_molecules_per_bc]}"
        " 2> {log} |"
        " tee {output.bam}"
        " |"
        " samtools index  - {output.bai}"


rule bam_to_fastq:
    """Convert final BAM file to FASTQ files for read 1 and 2"""
    output:
        r1_fastq = "reads.1.final.fastq.gz",
        r2_fastq = "reads.2.final.fastq.gz"
    input:
        bam = "mapped.sorted.tag.bcmerge.mkdup.mol.filt.bam"
    log: "samtools-fastq.log"
    threads: 20
    shell:
        "samtools fastq"
        " -@ {threads}"
        " -T {config[cluster_tag]},{config[sequence_tag]}"
        " {input.bam}"
        " -1 {output.r1_fastq}"
        " -2 {output.r2_fastq} 2> {log}"


rule symlink_reference_variants:
    output: "variants.reference.vcf"
    shell:
        "ln -s {config[reference_variants]} {output}"


rule recal_base_qual_scores:
    """Recalibrate base calling qualities"""
    output:
        recal_table = "{base}.gatk_BQSR_table.txt"
    input:
        bam = "{base}.sorted.tag.bcmerge.mkdup.mol.filt.bam"
    log: "{base}.gatk_BQSR_table.txt.log"
    shell:
        "gatk --java-options -Xmx{config[heap_space]}g BaseRecalibrator"
        " -R {config[genome_reference]}"
        " --known-sites {config[dbSNP]}"
        " -I {input.bam}"
        " -O {output.recal_table}"
        " 2> {log}"


rule apply_recal:
    """Adjusts BAM with results from gatk base score recalibration"""
    output:
        recal_bam = "{base}.sorted.tag.bcmerge.mkdup.mol.filt.BQSR.bam"
    input:
        bam = "{base}.sorted.tag.bcmerge.mkdup.mol.filt.bam",
        recal_table = "{base}.gatk_BQSR_table.txt"
    log: "{base}.sorted.tag.bcmerge.mkdup.mol.filter.BQSR.bam.log"
    shell:
        "gatk --java-options -Xmx{config[heap_space]}g ApplyBQSR"
        " --bqsr-recal-file {input.recal_table}"
        " -R {config[genome_reference]}"
        " -I {input.bam}"
        " -O {output.recal_bam}"
        " 2> {log}"


rule index_bam:
    output:
        bai = "{base}.bam.bai"
    input:
        bam = "{base}.bam"
    log: "{base}.samtools_index.log"
    shell:
        "samtools index"
        " {input.bam}"
        " {output.bai}"


def get_input_call_variants(wildcards):
    basename = "mapped.sorted.tag.bcmerge.mkdup.mol.filt"
    if config["variant_caller"] == "gatk" and config["BQSR"]:
        basename += ".BQSR"

    return {"bam": f"{basename}.bam",
            "bai": f"{basename}.bam.bai"}


rule call_variants:
    """Call variants using the selected variant caller from configs."""
    output:
         vcf = "variants.called.vcf"
    input:
         unpack(get_input_call_variants)
    log: "variants.called.vcf.log"
    threads: 2
    run:
        commands = {
            "freebayes":
                 "freebayes"
                 " -f {config[genome_reference]}"
                 " {input.bam}"
                 " 2> {log}"
                 " | "
                 # Filter out variants with allele count above 0 as these are detected as polyploid by hapcut2
                 "vcffilter"
                 " -f"
                 " 'AC > 0'"
                 " 1> {output.vcf} 2>> {log}",
            "bcftools":
                "bcftools mpileup"
                " -f {config[genome_reference]}"
                " {input.bam}"
                " --threads {threads}"
                " 2> {log}"
                " | "
                "bcftools call"
                " -m"
                " -v"
                " -O v"
                " --ploidy GRCh38"
                " --threads {threads}"
                " -o {output.vcf} 2>> {log}",
            "gatk":
                "gatk --java-options '-Xmx{config[heap_space]}g -XX:ParallelGCThreads={threads}' HaplotypeCaller"
                " -R {config[genome_reference]}"
                " -I {input.bam}"
                " -O {output.vcf} 2> {log}",
            # This option is currently not included in the pipeline documentation, but it will run on any system which
            # - runs Linux (it's not maintained for any other system)
            # - has deepvariant installed (e.g. through conda)
            # TODO: Add a conditional installation of deepvariant for Linux systems and add to pipeline docs.
            "deepvariant":
                "deepvariant"
	            " --model_type=WGS"
	            " --output_vcf={output.vcf}"
	            " --reads={input.bam}"
	            " --ref={config[genome_reference]}"
                }

        command = commands[config["variant_caller"]].format(**locals(), **globals())

        shell(
            "{command}"
        )
