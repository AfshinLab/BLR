from snakemake.utils import validate
import os

configfile: "blr.yaml"
validate(config, "config.schema.yaml")

# Import rules for trimming fastq files.
include: "rules/trim.smk"

# Import rules for phasing
include: "rules/phasing.smk"


rule final:
    input: "reads.1.final.fastq.gz", "reads.2.final.fastq.gz"


rule compress:
    output: "{sample}.fastq.gz"
    input: "{sample}.fastq"
    shell:
        "pigz < {input} > {output}"


rule tag_fastq:
    output:
        r1_fastq="trimmed_barcoded.1.fastq.gz",
        r2_fastq="trimmed_barcoded.2.fastq.gz"
    input:
        r1_fastq="trimmed.1.fastq.gz",
        r2_fastq="trimmed.2.fastq.gz",
        raw_barcodes="barcodes.fastq.gz",
        corr_barcodes="barcodes.clstr"
    log: "tag_fastq.log"
    shell:
        "blr tagfastq"
        " --o1 {output.r1_fastq}"
        " --o2 {output.r2_fastq}"
        " {input.raw_barcodes}"
        " {input.corr_barcodes}"
        " {input.r1_fastq}"
        " {input.r2_fastq}"
        " 2> {log}"


rule starcode_clustering:
    # Cluster DBS barcodes using starcode
    output:
        "barcodes.clstr"
    input:
        "barcodes.fastq"
    threads: 20
    log: "starcode_clustering.log"
    shell:
        "starcode"
        " -i {input}"
        " -o {output}"
        " -t {threads}"
        " -d 2"
        " --print-clusters"
        " 2> {log}"


rule bowtie2_mapping:
    # Mapping of trimmed FASTQ to reference using bowtie2 and sorting output using samtools.
    output:
        bam = "mapped.sorted.bam"
    input:
        r1_fastq = "trimmed_barcoded.1.fastq.gz",
        r2_fastq = "trimmed_barcoded.2.fastq.gz"
    threads: 20
    params:
        reference = config["bowtie2_reference"]
    log: "bowtie2_mapping.log"
    shell:
        "bowtie2"
        " --reorder"
        " -1 {input.r1_fastq}"
        " -2 {input.r2_fastq}"
        " -x {params.reference}"
        " --maxins 2000"
        " -p {threads} 2> {log} |"
        "samtools sort -"
        " -@ {threads}"
        " -O BAM > {output.bam}"


rule tagbam:
    # Add barcodes to BAM
    output:
        bam = "mapped.sorted.tag.bam"
    input:
        bam = "mapped.sorted.bam"
    log: "tag_bam.stderr"
    shell:
        "blr tagbam"
        " {input.bam}"
        " {output.bam}"
        " --bc {config[cluster_tag]} 2> {log}"


rule mark_duplicates:
    output:
        bam = "mapped.sorted.tag.mkdup.bam"
    input:
        bam = "mapped.sorted.tag.bam"
    log:
        metrics = "picard_mkdup_metrics.log",
        stderr = "picard_mkdup.log"
    params:
        picard_command = config["picard_command"],
        heap_space=config["heap_space"]
    shell:
        "{params.picard_command} -Xms{params.heap_space}g MarkDuplicates"
        " I={input.bam}"
        " O={output.bam}"
        " M={log.metrics}"
        " ASSUME_SORT_ORDER=coordinate 2> {log.stderr}"


rule clusterrmdup:
    # Removes cluster duplicates and indexes output
    output:
        bam = "mapped.sorted.tag.mkdup.bcmerge.bam",
        merges = "barcode-merges.csv"
    input:
        bam = "mapped.sorted.tag.mkdup.bam"
    log: "clusterrmdup.log"
    shell:
        "blr clusterrmdup"
        " {input.bam}"
        " {output.bam}"
        " {output.merges}"
        " -bc {config[cluster_tag]} 2>> {log}"


rule buildmolecules:
    # Groups reads into molecules depending on their genomic position and barcode
    output:
        bam = "mapped.sorted.tag.mkdup.bcmerge.mol.bam"
    input:
        bam = "mapped.sorted.tag.mkdup.bcmerge.bam"
    log: "buildmolecules.log"
    shell:
        "blr buildmolecules"
        " {input.bam}"
        " {output.bam}"
        " -m {config[molecule_tag]}"
        " -n {config[num_mol_tag]}"
        " -bc {config[cluster_tag]}"
        " 2> {log}"


rule filterclusters:
    # Filter clusters based on parameters
    output:
        bam = "mapped.sorted.tag.mkdup.bcmerge.mol.filt.bam",
        bai = "mapped.sorted.tag.mkdup.bcmerge.mol.filt.bam.bai"
    input:
        bam = "mapped.sorted.tag.mkdup.bcmerge.mol.bam"
    log: "filterclusters.log"
    shell:
        "blr filterclusters"
        " {input.bam}"
        " -"
        " -mn {config[num_mol_tag]}"
        " -M 260"
        " -t {config[cluster_tag]} {config[molecule_tag]} {config[num_mol_tag]} {config[sequence_tag]}"
        " 2>> {log} |"
        " tee {output.bam} |"
        " samtools index  - {output.bai}"


rule bam_to_fastq:
    # Convert final BAM file to FASTQ files for read 1 and 2
    output:
        r1_fastq = "reads.1.final.fastq",
        r2_fastq = "reads.2.final.fastq"
    input:
        bam = "mapped.sorted.tag.mkdup.bcmerge.mol.filt.bam"
    log: "picard_samtofastq.log"
    params:
        picard_command = config["picard_command"],
        heap_space=config["heap_space"]
    shell:
        "{params.picard_command} -Xms{params.heap_space}g SamToFastq"
        " I={input.bam}"
        " FASTQ={output.r1_fastq}"
        " SECOND_END_FASTQ={output.r2_fastq} 2>> {log}"


if config['reference_variants']:
    rule link:
        output: "reference.vcf"
        params: config['reference_variants']
        run:
            cmd = "ln -s " + os.path.abspath(config['reference_variants']) + " " + str(output)
            shell(cmd)
else:
    rule call_variants_freebayes:
        output:
             vcf = "reference.vcf"
        input:
             bam = "mapped.sorted.tag.mkdup.bcmerge.mol.filt.bam"
        log: "call_variants_freebayes.log"
        params:
            reference = config["bowtie2_reference"] + ".fasta" # I am unsure if this is a good solution, but it works.
        shell:
             "freebayes"
             " -f {params.reference}"
             " {input.bam} 1> {output.vcf} 2> {log}"
